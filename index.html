<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="theme-color" content="#0B071A" />
    
    <!-- SEO Meta Tags -->
    <title>fillshy - Autonomous AI Content Pipeline | Generate Content 24/7</title>
    <meta name="description" content="Generate diverse content 24/7 with AI and save it directly to your GitHub repository. Autonomous AI Content Pipeline for developers." />
    <meta name="keywords" content="AI content, GitHub automation, content pipeline, autonomous AI, content generation, fillshy, AI automation" />
    <meta name="author" content="fillshy" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="./" />
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="apple-touch-icon" href="/favicon.svg" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="./" />
    <meta property="og:site_name" content="fillshy" />
    <meta property="og:title" content="fillshy - Autonomous AI Content Pipeline" />
    <meta property="og:description" content="Generate diverse content 24/7 with AI and save it directly to your GitHub repository." />
    <meta property="og:locale" content="pt_BR" />
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="./" />
    <meta name="twitter:title" content="fillshy - Autonomous AI Content Pipeline" />
    <meta name="twitter:description" content="Generate diverse content 24/7 with AI and save it directly to your GitHub repository." />
    <meta name="twitter:site" content="@fillshy" />
    <meta name="twitter:creator" content="@fillshy" />

    <!-- Preconnect para otimização -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="preconnect" href="https://unpkg.com" />
    <link rel="preconnect" href="https://cdn.jsdelivr.net" />
    <link rel="preconnect" href="https://esm.sh" />
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Sora:wght@600;700&display=swap" rel="stylesheet" />
    
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              heading: ['Sora', 'sans-serif'],
            },
            keyframes: {
              'reveal-word': {
                'from': { opacity: '0', transform: 'translateY(10px)' },
                'to': { opacity: '1', transform: 'translateY(0)' },
              },
              'letter-reveal': {
                '0%': { opacity: 0, transform: 'translateY(20px) scale(0.8)' },
                '100%': { opacity: 1, transform: 'translateY(0) scale(1)' },
              },
              'logo-bar-1': {
                '0%': { transform: 'translateY(-40px)', opacity: 0 },
                '100%': { transform: 'translateY(0)', opacity: 1 },
              },
              'logo-bar-2': {
                '0%': { transform: 'translateY(40px)', opacity: 0 },
                '100%': { transform: 'translateY(0)', opacity: 1 },
              },
              'blob-animation': {
                '0%': { transform: 'translate(0px, 0px) scale(1)' },
                '33%': { transform: 'translate(30px, -50px) scale(1.1)' },
                '66%': { transform: 'translate(-20px, 20px) scale(0.9)' },
                '100%': { transform: 'translate(0px, 0px) scale(1)' },
              },
              'fade-in': {
                'from': { opacity: 0 },
                'to': { opacity: 1 },
              },
            },
            animation: {
              'reveal-word': 'reveal-word 0.5s cubic-bezier(0.215, 0.61, 0.355, 1) forwards',
              'letter-reveal': 'letter-reveal 0.6s cubic-bezier(0.215, 0.61, 0.355, 1) forwards',
              'logo-bar-1': 'logo-bar-1 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) forwards',
              'logo-bar-2': 'logo-bar-2 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) forwards',
              'blob': 'blob-animation 20s infinite ease-in-out',
              'fade-in': 'fade-in 0.3s ease-in-out',
            }
          }
        }
      }
    </script>

    <style>
      html {
        overflow-y: auto;
      }
      .scrollbar-hide {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      .scrollbar-hide::-webkit-scrollbar {
        display: none;
      }
    </style>

    <!-- SystemJS para gerenciamento de módulos -->
    <script src="https://cdn.jsdelivr.net/npm/systemjs@6.14.2/dist/system.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/systemjs@6.14.2/dist/extras/named-register.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/systemjs@6.14.2/dist/extras/amd.min.js"></script>
    
    <!-- Babel Standalone para transpilação -->
    <script src="https://unpkg.com/@babel/standalone@7.24.0/babel.min.js"></script>
    
    <!-- Import Map -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react/": "https://esm.sh/react@18.2.0/",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/": "https://esm.sh/react-dom@18.2.0/",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "@google/genai": "https://esm.sh/@google/generative-ai@0.1.3",
        "vite": "https://esm.sh/vite@5.0.0",
        "@vitejs/plugin-react": "https://esm.sh/@vitejs/plugin-react@4.2.0"
      }
    }
    </script>

    <!-- Sistema de Transpilação TSX/TS -->
    <script>
      // Configuração global
      window.__DEV__ = true;
      window.__TRANSPILE_CACHE__ = new Map();
      window.__MODULE_CACHE__ = new Map();
      window.__BASE_URL__ = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/');

      // Sistema de transpilação e carregamento de módulos
      class TSXTranspiler {
        constructor() {
          this.cache = window.__TRANSPILE_CACHE__;
          this.moduleCache = window.__MODULE_CACHE__;
          this.pendingModules = new Set();
        }

        // Resolve caminho relativo para absoluto
        resolvePath(importPath, basePath = '') {
          console.log(`[TSXTranspiler] Resolvendo: ${importPath} com base: ${basePath}`);
          
          // Se já é uma URL completa, retorna
          if (importPath.startsWith('http://') || importPath.startsWith('https://')) {
            return importPath;
          }

          // Se é um import de biblioteca (não começa com . ou /)
          if (!importPath.startsWith('.') && !importPath.startsWith('/')) {
            console.log(`[TSXTranspiler] Import de biblioteca detectado: ${importPath}`);
            return importPath;
          }

          // Adiciona extensões se necessário
          let resolvedPath = importPath;
          if (!resolvedPath.match(/\.(tsx?|jsx?)$/)) {
            // Tenta adicionar .tsx primeiro, depois .ts, .jsx, .js
            const extensions = ['.tsx', '.ts', '.jsx', '.js'];
            resolvedPath = importPath;
          }

          // Resolve caminho relativo
          if (resolvedPath.startsWith('./') || resolvedPath.startsWith('../')) {
            const base = basePath || window.__BASE_URL__;
            const baseDir = base.replace(/\/[^\/]*$/, '/');
            const resolved = new URL(resolvedPath, baseDir).href;
            console.log(`[TSXTranspiler] Caminho resolvido: ${resolved}`);
            return resolved;
          }

          // Caminho absoluto do site
          if (resolvedPath.startsWith('/')) {
            const resolved = window.__BASE_URL__ + resolvedPath.substring(1);
            console.log(`[TSXTranspiler] Caminho absoluto resolvido: ${resolved}`);
            return resolved;
          }

          return resolvedPath;
        }

        // Busca arquivo fonte
        async fetchSource(url) {
          console.log(`[TSXTranspiler] Buscando arquivo: ${url}`);
          
          try {
            // Tenta diferentes extensões
            const extensions = ['', '.tsx', '.ts', '.jsx', '.js'];
            
            for (const ext of extensions) {
              const fullUrl = url + ext;
              try {
                const response = await fetch(fullUrl);
                if (response.ok) {
                  const source = await response.text();
                  console.log(`[TSXTranspiler] Arquivo encontrado: ${fullUrl}`);
                  return { source, url: fullUrl };
                }
              } catch (e) {
                continue;
              }
            }
            
            throw new Error(`Arquivo não encontrado: ${url}`);
          } catch (error) {
            console.error(`[TSXTranspiler] Erro ao buscar ${url}:`, error);
            throw error;
          }
        }

        // Transpila código TypeScript/TSX para JavaScript
        transpile(source, filename = 'module.tsx') {
          console.log(`[TSXTranspiler] Transpilando: ${filename}`);
          
          try {
            const result = Babel.transform(source, {
              filename,
              presets: [
                ['react', { runtime: 'automatic' }],
                ['typescript', { isTSX: true, allExtensions: true }]
              ],
              plugins: [
                'transform-modules-systemjs'
              ]
            });

            console.log(`[TSXTranspiler] Transpilação concluída: ${filename}`);
            return result.code;
          } catch (error) {
            console.error(`[TSXTranspiler] Erro na transpilação de ${filename}:`, error);
            throw error;
          }
        }

        // Processa imports no código transpilado
        processImports(code, basePath) {
          console.log(`[TSXTranspiler] Processando imports em: ${basePath}`);
          
          // Regex para encontrar imports
          const importRegex = /from\s+['"]([^'"]+)['"]/g;
          let match;
          const imports = [];

          while ((match = importRegex.exec(code)) !== null) {
            imports.push(match[1]);
          }

          // Resolve todos os imports
          let processedCode = code;
          imports.forEach(importPath => {
            const resolved = this.resolvePath(importPath, basePath);
            if (resolved !== importPath) {
              processedCode = processedCode.replace(
                new RegExp(`from\\s+['"]${importPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"]`, 'g'),
                `from '${resolved}'`
              );
            }
          });

          return { code: processedCode, imports };
        }

        // Cria blob URL para módulo
        createBlobModule(code) {
          const blob = new Blob([code], { type: 'application/javascript' });
          const blobUrl = URL.createObjectURL(blob);
          console.log(`[TSXTranspiler] Blob criado: ${blobUrl}`);
          return blobUrl;
        }

        // Carrega e transpila módulo
        async loadModule(modulePath, basePath = '') {
          const resolvedPath = this.resolvePath(modulePath, basePath);
          
          console.log(`[TSXTranspiler] Carregando módulo: ${resolvedPath}`);

          // Verifica cache
          if (this.moduleCache.has(resolvedPath)) {
            console.log(`[TSXTranspiler] Módulo em cache: ${resolvedPath}`);
            return this.moduleCache.get(resolvedPath);
          }

          // Previne carregamento duplicado
          if (this.pendingModules.has(resolvedPath)) {
            console.log(`[TSXTranspiler] Módulo já está sendo carregado: ${resolvedPath}`);
            return new Promise((resolve) => {
              const interval = setInterval(() => {
                if (this.moduleCache.has(resolvedPath)) {
                  clearInterval(interval);
                  resolve(this.moduleCache.get(resolvedPath));
                }
              }, 100);
            });
          }

          this.pendingModules.add(resolvedPath);

          try {
            // Busca o arquivo
            const { source, url } = await this.fetchSource(resolvedPath);

            // Transpila
            const transpiledCode = this.transpile(source, url);

            // Processa imports
            const { code: processedCode, imports } = this.processImports(transpiledCode, url);

            // Carrega dependências recursivamente
            await Promise.all(
              imports.map(imp => {
                if (imp.startsWith('.') || imp.startsWith('/')) {
                  return this.loadModule(imp, url);
                }
                return Promise.resolve();
              })
            );

            // Cria blob
            const blobUrl = this.createBlobModule(processedCode);

            // Registra no SystemJS
            const moduleExports = await System.import(blobUrl);

            // Armazena em cache
            this.moduleCache.set(resolvedPath, moduleExports);
            this.pendingModules.delete(resolvedPath);

            console.log(`[TSXTranspiler] Módulo carregado com sucesso: ${resolvedPath}`);
            return moduleExports;

          } catch (error) {
            this.pendingModules.delete(resolvedPath);
            console.error(`[TSXTranspiler] Erro ao carregar módulo ${resolvedPath}:`, error);
            throw error;
          }
        }
      }

      // Inicializa o transpilador
      window.tsxTranspiler = new TSXTranspiler();

      // Função para iniciar a aplicação
      async function initApp() {
        console.log('[App] Iniciando aplicação...');
        
        try {
          // Carrega o módulo principal
          console.log('[App] Carregando index.tsx...');
          const mainModule = await window.tsxTranspiler.loadModule('./index.tsx');
          
          console.log('[App] Aplicação carregada com sucesso!');
          
        } catch (error) {
          console.error('[App] Erro ao inicializar a aplicação:', error);
          
          // Exibe erro na tela
          const root = document.getElementById('root');
          if (root) {
            root.innerHTML = `
              <div style="
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
                padding: 2rem;
                text-align: center;
                background: #0B071A;
                color: #E0DDF0;
              ">
                <h1 style="font-size: 2rem; margin-bottom: 1rem; color: #ff6b6b;">
                  ⚠️ Erro ao Carregar Aplicação
                </h1>
                <pre style="
                  background: #1a1625;
                  padding: 1rem;
                  border-radius: 8px;
                  max-width: 600px;
                  overflow-x: auto;
                  text-align: left;
                  border: 1px solid #ff6b6b;
                ">${error.message}\n\n${error.stack || ''}</pre>
                <p style="margin-top: 1rem; opacity: 0.7;">
                  Verifique o console para mais detalhes
                </p>
              </div>
            `;
          }
        }
      }

      // Aguarda o DOM estar pronto
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initApp);
      } else {
        initApp();
      }
    </script>
  </head>
  
  <body class="bg-[#0B071A] text-[#E0DDF0] font-sans">
    <noscript>
      <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; padding: 2rem; text-align: center; background: #0B071A; color: #E0DDF0;">
        <div>
          <h1 style="font-size: 2rem; margin-bottom: 1rem;">JavaScript Necessário</h1>
          <p>Você precisa habilitar o JavaScript para executar esta aplicação.</p>
        </div>
      </div>
    </noscript>
    
    <div id="root"></div>
  </body>
</html>
