<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#0B071A" />

  <!-- SEO -->
  <title>fillshy - Autonomous AI Content Pipeline</title>
  <meta name="description"
        content="Generate diverse content 24/7 with AI and save it directly to your GitHub repository." />
  <!-- ... (suas outras metatags SEO) ... -->
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Sora:wght@600;700&display=swap"
    rel="stylesheet" media="print" onload="this.media='all'">
  <noscript><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Sora:wght@600;700&display=swap" rel="stylesheet"></noscript>

  <!-- =================================================================== -->
  <!-- CSS DO LOADER IMEDIATO (Réplica da sua animação Tailwind)           -->
  <!-- Isso executa instantaneamente, eliminando a tela branca.            -->
  <!-- =================================================================== -->
  <style>
    /* Estilos base para garantir que não haja "pulos" de layout/cor */
    html { overflow-y: auto; }
    body {
      background-color: #0B071A; /* Mesmo do seu Tailwind */
      color: #E0DDF0;
      font-family: 'Inter', sans-serif;
    }

    /* Oculta a aplicação React até que ela esteja PRONTA */
    #root {
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }
    
    /* Estilos do loader/pré-carregador */
    #loader {
      position: fixed;
      inset: 0; /* Ocupa a tela inteira */
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #0B071A;
      transition: opacity 0.5s ease-in-out; /* Para sumir suavemente */
    }
    .loader-logo {
      position: relative;
      width: 48px;
      height: 48px;
    }
    .loader-logo::before,
    .loader-logo::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 100%;
      background-color: #E0DDF0;
      border-radius: 8px;
      opacity: 0;
    }
    .loader-logo::before {
      left: 0;
      /* Aplica a animação 'logo-bar-1' definida abaixo */
      animation: loader-logo-bar-1 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) forwards;
    }
    .loader-logo::after {
      right: 0;
      /* Aplica a animação 'logo-bar-2' e adiciona um pequeno delay */
      animation: loader-logo-bar-2 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) forwards;
      animation-delay: 0.15s;
    }

    /* Keyframes replicados do seu Tailwind.config */
    @keyframes loader-logo-bar-1 {
      '0%':   { transform: translateY(-40px)', opacity: 0 }
      '100%': { transform: translateY(0)', opacity: 1 }
    }
    @keyframes loader-logo-bar-2 {
      '0%':   { transform: translateY(40px)', opacity: 0 }
      '100%': { transform: translateY(0)', opacity: 1 }
    }
  </style>

  <!-- Pré-carrega o entry point, boa prática que você já tinha -->
  <link rel="preload" href="/index.tsx" as="fetch" crossorigin="anonymous" />
  
  <!-- Tailwind CDN (carregado com 'defer' para não bloquear) -->
  <script src="https://cdn.tailwindcss.com" defer></script>
  <script>
    // Sua CONFIGURAÇÃO DO TAILWIND permanece INTACTA
    tailwind.config = {
      theme: { extend: { fontFamily: { sans: ['Inter', 'sans-serif'], heading: ['Sora', 'sans-serif'], }, keyframes: { 'reveal-word': { from: { opacity: '0', transform: 'translateY(10px)' }, to:   { opacity: '1', transform: 'translateY(0)' }, }, 'letter-reveal': { '0%':   { opacity: 0, transform: 'translateY(20px) scale(0.8)' }, '100%': { opacity: 1, transform: 'translateY(0) scale(1)' }, }, 'logo-bar-1': { '0%':   { transform: 'translateY(-40px)', opacity: 0 }, '100%': { transform: 'translateY(0)', opacity: 1 }, }, 'logo-bar-2': { '0%':   { transform: 'translateY(40px)', opacity: 0 }, '100%': { transform: 'translateY(0)', opacity: 1 }, }, 'blob-animation': { '0%':   { transform: 'translate(0px, 0px) scale(1)' }, '33%':  { transform: 'translate(30px, -50px) scale(1.1)' }, '66%':  { transform: 'translate(-20px, 20px) scale(0.9)' }, '100%': { transform: 'translate(0px, 0px) scale(1)' }, }, 'fade-in': { from: { opacity: 0 }, to:   { opacity: 1 }, }, }, animation: { 'reveal-word': 'reveal-word 0.5s cubic-bezier(0.215, 0.61, 0.355, 1) forwards', 'letter-reveal': 'letter-reveal 0.6s cubic-bezier(0.215, 0.61, 0.355, 1) forwards', 'logo-bar-1': 'logo-bar-1 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) forwards', 'logo-bar-2': 'logo-bar-2 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) forwards', 'blob': 'blob-animation 20s infinite ease-in-out', 'fade-in': 'fade-in 0.3s ease-in-out', } } },
      plugins: [ function ({ addUtilities }) { addUtilities({ '.scrollbar-hide': { '-ms-overflow-style': 'none', 'scrollbar-width': 'none', '&::-webkit-scrollbar': { display: 'none' } } }) } ]
    }
  </script>

  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone@7.24.7/babel.min.js"></script>

  <!-- Import map das libs -->
  <script type="importmap">
    { "imports": { "react": "https://esm.sh/react@18.2.0", "react-dom/client": "https://esm.sh/react-dom@18.2.0/client", "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime", "@google/genai": "https://esm.sh/@google/genai@0.14.0" } }
  </script>
</head>

<body class="bg-[#0B071A] text-[#E0DDF0] font-sans">
  <noscript>Você precisa habilitar o JavaScript para rodar esta aplicação.</noscript>
  
  <!-- Loader que aparece instantaneamente para o usuário -->
  <div id="loader">
    <div class="loader-logo"></div>
  </div>

  <!-- Raiz da aplicação React, começa invisível -->
  <div id="root"></div>

  <script type="module">
    // SEU SCRIPT FOI 100% PRESERVADO. A ÚNICA MUDANÇA É NO 'FINALLY'
    const blobCache = new Map();

    async function loadSource(path, parentUrl) {
      const baseUrl = new URL(path, parentUrl).href;
      if (/\.(tsx?|jsx?)($|\?)/.test(baseUrl)) {
        const res = await fetch(baseUrl);
        if (!res.ok) throw new Error('Não foi possível carregar ' + baseUrl);
        return { absoluteUrl: baseUrl, sourceCode: await res.text() };
      }
      const base = baseUrl.replace(/\/$/, '');
      const candidates = [
        base + '.tsx', base + '.ts', base + '/index.tsx', base + '/index.ts',
      ];
      for (const url of candidates) {
        try {
          const res = await fetch(url);
          if (res.ok) { return { absoluteUrl: url, sourceCode: await res.text() }; }
        } catch (_) {}
      }
      throw new Error('Não foi possível encontrar o arquivo para ' + baseUrl);
    }

    async function resolveAndTranspile(entryPath, parentUrl = window.location.href) {
      const { absoluteUrl, sourceCode } = await loadSource(entryPath, parentUrl);
      if (blobCache.has(absoluteUrl)) { return blobCache.get(absoluteUrl); }
      const importRegex = /\bimport\s+[^'"]*['"](.*?)['"]/g;
      const dependencies = new Map();
      let match;
      while ((match = importRegex.exec(sourceCode)) !== null) {
        if (match[1].startsWith('.')) { dependencies.set(match[1], null); }
      }
      await Promise.all(
        Array.from(dependencies.keys()).map(async (depPath) => {
          const childBlobUrl = await resolveAndTranspile(depPath, absoluteUrl);
          dependencies.set(depPath, childBlobUrl);
        })
      );
      let transformedCode = sourceCode;
      for (const [originalPath, blobUrl] of dependencies.entries()) {
        const re = new RegExp(`(['"])${originalPath}\\1`, 'g');
        transformedCode = transformedCode.replace(re, `$1${blobUrl}$1`);
      }
      const { code } = Babel.transform(transformedCode, {
        presets: [ ['react', { runtime: 'automatic' }], ['typescript', { allExtensions: true, isTSX: true }] ],
        sourceType: 'module', filename: absoluteUrl
      });
      const blobUrl = URL.createObjectURL(
        new Blob([code], { type: 'application/javascript' })
      );
      blobCache.set(absoluteUrl, blobUrl);
      return blobUrl;
    }

    (async () => {
      const rootEl = document.getElementById('root');
      const loaderEl = document.getElementById('loader');
      try {
        const entryModuleUrl = await resolveAndTranspile('/index.tsx');
        await import(entryModuleUrl);

      } catch (error) {
        console.error('Falha ao inicializar a aplicação:', error);
        rootEl.innerHTML = `<div style="color:#ff8b8b; background:#2b0f0f; padding:20px; border-radius:8px; font-family:monospace; white-space:pre-wrap;"><h2>Erro na Aplicação</h2><p>${error.message}</p></div>`;

      } finally {
        // ---- AQUI ESTÁ A MÁGICA ----
        // Quando a aplicação React está pronta (mesmo que com erro)...

        // 1. Mostra a div #root com a aplicação React.
        rootEl.style.opacity = '1';

        // 2. Esconde o loader.
        loaderEl.style.opacity = '0';
        
        // 3. Remove o loader da página após a animação de fade-out terminar.
        setTimeout(() => {
          loaderEl.remove();
        }, 500); // Duração igual à transição do CSS (0.5s)
      }
    })();
  </script>
</body>
</html>
