<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#0B071A" />
    
    <!-- SEO e Social Sharing -->
    <title>fillshy - Autonomous AI Content Pipeline</title>
    <meta name="description" content="Generate diverse content 24/7 with AI and save it directly to your GitHub repository." />
    <link rel="canonical" href="./" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="./" />
    <meta property="og:title" content="fillshy - Autonomous AI Content Pipeline" />
    <meta property="og:description" content="Generate diverse content 24/7 with AI and save it directly to your GitHub repository." />
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="./" />
    <meta property="twitter:title" content="fillshy - Autonomous AI Content Pipeline" />
    <meta property="twitter:description" content="Generate diverse content 24/7 with AI and save it directly to your GitHub repository." />

    <!-- Pré-conexão com as CDNs -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://esm.sh">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Sora:wght@600;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: { sans: ['Inter','sans-serif'], heading: ['Sora','sans-serif'] },
            keyframes: { 'reveal-word':{from:{opacity:'0',transform:'translateY(10px)'},to:{opacity:'1',transform:'translateY(0)'}}, 'letter-reveal':{'0%':{opacity:0,transform:'translateY(20px) scale(0.8)'},'100%':{opacity:1,transform:'translateY(0) scale(1)'}}, 'logo-bar-1':{'0%':{transform:'translateY(-40px)',opacity:0},'100%':{transform:'translateY(0)',opacity:1}}, 'logo-bar-2':{'0%':{transform:'translateY(40px)',opacity:0},'100%':{transform:'translateY(0)',opacity:1}}, 'blob-animation':{'0%':{transform:'translate(0px, 0px) scale(1)'},'33%':{transform:'translate(30px, -50px) scale(1.1)'},'66%':{transform:'translate(-20px, 20px) scale(0.9)'},'100%':{transform:'translate(0px, 0px) scale(1)'}}, 'fade-in':{from:{opacity:0},to:{opacity:1}} },
            animation: { 'reveal-word':'reveal-word 0.5s cubic-bezier(0.215, 0.61, 0.355, 1) forwards', 'letter-reveal':'letter-reveal 0.6s cubic-bezier(0.215, 0.61, 0.355, 1) forwards', 'logo-bar-1':'logo-bar-1 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) forwards', 'logo-bar-2':'logo-bar-2 0.8s cubic-bezier(0.215, 0.61, 0.355, 1) forwards', 'blob':'blob-animation 20s infinite ease-in-out', 'fade-in':'fade-in 0.3s ease-in-out' }
          }
        },
        plugins: [ function({addUtilities}){addUtilities({'.scrollbar-hide':{'-ms-overflow-style': 'none','scrollbar-width': 'none','&::-webkit-scrollbar':{display: 'none'}}})} ]
      }
    </script>
    
    <!-- Import maps -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "@google/genai": "https://esm.sh/@google/genai@0.14.0"
      }
    }
    </script>
    
    <!-- Babel -->
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-[#0B071A] text-[#E0DDF0] font-sans">
    <noscript>Você precisa habilitar o JavaScript para rodar esta aplicação.</noscript>
    <div id="root"></div>

    <!-- SCRIPT CORRIGIDO E FINALMENTE RÁPIDO -->
    <script type="module">
        console.time('Tempo Total de Carregamento');
        const fileCache = new Map(); // Cache para arquivos já processados
        const rootElement = document.getElementById('root');

        const showError = (error) => {
            console.error("Falha ao carregar a aplicação:", error);
            rootElement.innerHTML = `<div style="color:#ff8b8b; background:#2b0f0f; padding:20px; border-radius:8px; font-family:monospace; white-space:pre-wrap; margin: 2rem;"><h2>Erro na Aplicação</h2><p>${error.message}</p><pre>${error.stack}</pre></div>`;
        };

        // --- NOVA FUNÇÃO OTIMIZADA ---
        // Tenta baixar o arquivo diretamente (GET), eliminando a requisição HEAD extra.
        async function findAndFetchFile(baseUrl) {
            const potentialPaths = [ baseUrl, `${baseUrl}.tsx`, `${baseUrl}.ts`, `${baseUrl}/index.tsx`, `${baseUrl}/index.ts` ];
            for (const path of potentialPaths) {
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        const sourceCode = await response.text();
                        // Retorna o caminho real e o código-fonte de uma vez só.
                        return { path, sourceCode }; 
                    }
                } catch (e) { /* Ignora erros de rede e tenta o próximo caminho */ }
            }
            return null; // Retorna null se nenhum caminho funcionar.
        }

        async function resolveAndTranspile(entryUrl) {
            const absoluteUrl = new URL(entryUrl, window.location.href).href;
            if (fileCache.has(absoluteUrl)) {
                return fileCache.get(absoluteUrl);
            }
            
            // A busca e o fetch acontecem aqui, em uma única chamada.
            const fileData = await findAndFetchFile(absoluteUrl);
            if (!fileData) throw new Error(`Não foi possível encontrar ou baixar o arquivo: ${entryUrl}`);

            const { path: foundPath, sourceCode } = fileData;

            // O resto da lógica é a mesma, mas agora muito mais rápida.
            const importRegex = /import\s+.*?from\s+['"](.*?)['"]/g;
            const dependencies = new Map();
            let match;
            
            while ((match = importRegex.exec(sourceCode)) !== null) {
                if (match[1].startsWith('.')) {
                    dependencies.set(match[1], null);
                }
            }
            
            const promises = Array.from(dependencies.keys()).map(async (depPath) => {
                const depUrl = new URL(depPath, foundPath).href;
                const resolvedBlobUrl = await resolveAndTranspile(depUrl);
                dependencies.set(depPath, resolvedBlobUrl);
            });
            
            await Promise.all(promises);

            let transformedCode = sourceCode;
            for (const [path, blobUrl] of dependencies.entries()) {
                if(blobUrl) {
                    transformedCode = transformedCode.replace(new RegExp(`['"]${path}['"]`, 'g'), `'${blobUrl}'`);
                }
            }
            
            const { code } = Babel.transform(transformedCode, {
                presets: [['react', { runtime: 'automatic' }], ['typescript', { allExtensions: true, isTSX: true }]],
                filename: foundPath, // Usa o caminho real encontrado para erros
            });

            const blob = new Blob([code], { type: 'application/javascript' });
            const blobUrl = URL.createObjectURL(blob);
            
            fileCache.set(absoluteUrl, blobUrl);
            return blobUrl;
        }

        (async () => {
            try {
                // O ponto de entrada continua o mesmo
                const entryModuleUrl = await resolveAndTranspile('/index');
                await import(entryModuleUrl);
                console.timeEnd('Tempo Total de Carregamento');
            } catch (error) {
                showError(error);
                console.timeEnd('Tempo Total de Carregamento');
            }
        })();
    </script>
</body>
</html>
